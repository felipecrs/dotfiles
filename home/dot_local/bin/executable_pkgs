#!/usr/bin/env -S pkgx -q deno@2 run --ext=ts --allow-all

import { PackageNotFoundError, PackageRequirement, PantryNotFoundError, Path, hooks, utils } from "https://deno.land/x/libpkgx@v0.20.3/mod.ts"
import undent from "jsr:@cspotcode/outdent@0.8.0";
import { stringify as stringifyYaml } from "jsr:@std/yaml@1.0.5";

const help = "pkgs: usage: pkgs install|uninstall <pkgs>"

const args = Deno.args

if (args.length < 1) {
  console.error(help);
  Deno.exit(1)
}

const cmd = args[0]
const pkgs = args.slice(1)

const bindir = Deno.uid() == 0 ? new Path("/usr/local/bin") : Path.home().join(".local/bin")

switch (cmd) {
  case "install":
    await install(pkgs)
    break
  case "uninstall":
    await uninstall(pkgs)
    break
  case "list":
    await list()
    break
  default:
    console.error(`pkgs: unknown command: ${cmd}`)
    Deno.exit(1)
}

type ShimContent = {
  siblings: string[]
}

async function install(pkgspecs: string[]) {
  const pkgs = await Promise.all(pkgspecs.map(x => parse_pkg_str(x, {latest: 'ok'})))

  if (pkgs.length <= 0) {
    console.error('pkgs: no pkgs specified')
    Deno.exit(1)
  }

  let n = 0

  for (const pkg of pkgs) {
    const programs = (await hooks.usePantry().project(pkg).provides()).filter(
      // skip for now since we would require specific versions and we haven't really got that
      p => !p.includes("{{")
    )
    const pkgstr = utils.pkg.str(pkg)

    bindir.mkdir('p')

    for (const program of programs) {
      const f = bindir.join(program)

      if (f.exists()) {
        if (!await isShim(f)) {
          console.error(`pkgs: ${f} already exists and is not a pkgx shim`);
          Deno.exit(1)
        }
        await uninstall([pkgstr]);
      }
    }

    for (const program of programs) {
      const f = bindir.join(program)

      const content: ShimContent = {
        siblings: programs
      }

      f.write({ force: true, text:
        `#!/usr/bin/env -S pkgx -! -q +${pkgstr} -- ${program}\n\n${stringifyYaml(content)}`
      }).chmod(0o755)
      console.error('pkgs: installed:', f)
      n++
    }
  }

  if (n == 0) {
    console.error('pkgs: no programs provided by pkgs')
    Deno.exit(1)
  }

  if (n > 0 && !Deno.env.get("PATH")?.split(":").includes(bindir.string)) {
    console.warn("pkgs: %c`%s` is not in `PATH`", 'color: red', bindir)
  }
}

async function uninstall(pkgspecs: string[]) {
  const pkgs = await Promise.all(pkgspecs.map(x => parse_pkg_str(x, {latest: 'ok'})))

  if (pkgs.length <= 0) {
    console.error('pkgs: no pkgs specified')
    Deno.exit(1)
  }

  let n = 0

  for (const pkg of pkgs) {
    const programs = await hooks.usePantry().project(pkg).provides()
    for (const program of programs) {
      const f = bindir.join(program)

      if (!f.exists()) {
        continue
      }

      if (!await isShim(f)) {
        console.error(`pkgs: ${f} is not a pkgx shim`);
        Deno.exit(1)
      }

      const content = await f.readYAML() as ShimContent

      const programs = [f, ...content.siblings.map(x => bindir.join(x))]

      for (const p of programs) {
        if (p.exists()) {
          p.rm()
          console.error('pkgs: uninstalled:', p)
          n++
        }
      }
    }
  }

  if (n == 0) {
    console.error('pkgs: nothing to uninstall');
  }
}

async function list() {
  if (!bindir.isDirectory()) {
    console.error(`pkgs: ${bindir} is not a directory`);
    Deno.exit(1)
  }

  let n = 0

  for await (const [entry] of bindir.walk()) {
    if (await isShim(entry)) {
      console.log(entry)
      n++
    }
  }

  if (n == 0) {
    console.error('pkgs: no programs installed');
  }
}

async function parse_pkg_str(input: string, opts?: { latest: 'ok' }): Promise<PackageRequirement & { update?: boolean }> {
  let update = false

  if (opts?.latest && input.endsWith("@latest")) {
    input = input.slice(0, -7)
    update = true
  }

  const rawpkg = utils.pkg.parse(input)

  const projects = await failsafe(() => hooks.usePantry().find(rawpkg.project))
  if (projects.length <= 0) {
    console.error(`pkgs: nothing provides \`${input}\``)
    Deno.exit(1)
  }
  if (projects.length > 1) {
    console.error(undent`
      pkgs: multiple projects provide \`${input}\`. please be more specific:

      ${projects.map(p => `    pkgs +${p.project} ${Deno.args.join(' ')}`).join('\n')}
      `)
  }

  const project = projects[0].project //FIXME libpkgx forgets to correctly assign type
  const constraint = rawpkg.constraint

  return { project, constraint, update }
}

async function failsafe<T>(body: () => Promise<T>): Promise<T> {
  try {
    return await body()
  } catch (err) {
    if (err instanceof PackageNotFoundError || err instanceof PantryNotFoundError) {
      await hooks.useSync()
      return body()
    } else {
      throw err
    }
  }
}

async function isShim(f: Path): Promise<boolean> {
  if (!f.isFile()) return false

  if (!await isShebang(f)) return false

  const { value: shebang } = await f.readLines().next()
  const shebangRegex = /^#!\/usr\/bin\/env -S pkgx -! /
  if (!shebang.match(shebangRegex)) {
    return false
  }

  try {
    const content = await f.readYAML() as ShimContent
    if (!content.siblings) {
      return false
    }
  } catch (_err) {
    return false
  }

  return true
}

async function isShebang(path: Path): Promise<boolean> {
  const fd = await Deno.open(path.string)
  const buf = new Uint8Array(2)

  if (await fd.read(buf) !== 2) {
    fd.close()
    return false // empty file
  }

  if (buf[0] != 35 || buf[1] != 33) {
    fd.close()
    return false // not an executable script
  }

  fd.close()
  return true
}
