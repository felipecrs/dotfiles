#!/usr/bin/env -S pkgx -q deno@2 run --ext=ts --allow-all

import { PackageNotFoundError, PackageRequirement, PantryNotFoundError, Path, hooks, utils } from "https://deno.land/x/libpkgx@v0.20.3/mod.ts"
import undent from "jsr:@cspotcode/outdent@0.8.0";
import { stringify as stringifyYaml } from "jsr:@std/yaml@1.0.5";

const args = Deno.args
if (args.length < 2) {
  console.error(undent`
    usage: pkgs install ...
           pkgs uninstall ...
    `)
  Deno.exit(1)
}

const cmd = args[0]
const pkgs = args.slice(1)

type ShimContent = {
  siblings: string[]
}

switch (cmd) {
  case "install":
    await install(pkgs)
    break
  case "uninstall":
    await uninstall(pkgs)
    break
  default:
    console.error(`pkgs: unknown command: ${cmd}`)
    Deno.exit(1)
}

async function install(pkgspecs: string[]) {
  const pkgs = await Promise.all(pkgspecs.map(x => parse_pkg_str(x, {latest: 'ok'})))

  let n = 0

  if (Deno.uid() == 0) {
    const usrlocal = new Path("/usr/local/bin")
    await write(usrlocal, pkgs)
  } else {
    const bindir = Path.home().join(".local/bin")
    await write(bindir, pkgs)
    if (n > 0 && !Deno.env.get("PATH")?.split(":").includes(bindir.string)) {
      console.warn("pkgx: %c`%s` is not in `PATH`", 'color: red', bindir)
    }
  }

  if (n == 0) {
    console.error('pkgx: no programs provided by pkgs')
    Deno.exit(1)
  }

  async function write(dst: Path, pkgs: PackageRequirement[]) {
    for (const pkg of pkgs) {
      const programs = (await hooks.usePantry().project(pkg).provides()).filter(
        // skip for now since we would require specific versions and we haven't really got that
        p => !p.includes("{{")
      )
      const pkgstr = utils.pkg.str(pkg)

      for (const program of programs) {
        const f = dst.join(program)

        if (f.exists()) {
          if (!await isShim(f)) {
            console.error(`pkgs: ${f} is already installed and is not a pkgx shim`);
            Deno.exit(1)
          }
          await uninstall([pkgstr]);
        }
      }

      for (const program of programs) {
        const f = dst.mkdir('p').join(program)

        const content: ShimContent = {
          siblings: programs
        }

        f.write({ force: true, text:
          `#!/usr/bin/env -S pkgx -! -q +${pkgstr} -- ${program}\n\n${stringifyYaml(content)}`
        }).chmod(0o755)
        console.error('pkgx: installed:', f)
        n++
      }
    }
  }
}

async function uninstall(pkgspecs: string[]) {
  const pkgs = await Promise.all(pkgspecs.map(x => parse_pkg_str(x, {latest: 'ok'})))

  if (Deno.uid() == 0) {
    await uninstall(new Path("/usr/local/bin"), pkgs)
  } else {
    await uninstall(Path.home().join(".local/bin"), pkgs)
  }

  async function uninstall(prefix: Path, pkgs: PackageRequirement[]) {
    for (const pkg of pkgs) {
      const programs = await hooks.usePantry().project(pkg).provides()
      for (const program of programs) {
        const f = prefix.join(program)

        if (!f.exists()) {
          continue
        }

        if (!await isShim(f)) {
          console.error(`pkgx: ${f} is not a pkgx shim`);
          Deno.exit(1)
        }

        const content = await f.readYAML() as ShimContent

        const programs = [f, ...content.siblings.map(x => prefix.join(x))]

        for (const p of programs) {
          if (p.exists()) {
            p.rm()
            console.error('pkgx: uninstalled:', p)
          }
        }
      }
    }
  }
}

async function parse_pkg_str(input: string, opts?: { latest: 'ok' }): Promise<PackageRequirement & { update?: boolean }> {
  let update = false

  if (opts?.latest && input.endsWith("@latest")) {
    input = input.slice(0, -7)
    update = true
  }

  const rawpkg = utils.pkg.parse(input)

  const projects = await failsafe(() => hooks.usePantry().find(rawpkg.project))
  if (projects.length <= 0) {
    console.error(`pkgs: nothing provides \`${input}\``)
    Deno.exit(1)
  }
  if (projects.length > 1) {
    console.error(undent`
      pkgs: multiple projects provide \`${input}\`. please be more specific:

      ${projects.map(p => `    pkgs +${p.project} ${Deno.args.join(' ')}`).join('\n')}
      `)
  }

  const project = projects[0].project //FIXME libpkgx forgets to correctly assign type
  const constraint = rawpkg.constraint

  return { project, constraint, update }
}

async function failsafe<T>(body: () => Promise<T>): Promise<T> {
  try {
    return await body()
  } catch (err) {
    if (err instanceof PackageNotFoundError || err instanceof PantryNotFoundError) {
      await hooks.useSync()
      return body()
    } else {
      throw err
    }
  }
}

async function isShim(f: Path): Promise<boolean> {
  if (!f.isFile()) return false

  if (!await isShebang(f)) return false

  const { value: shebang } = await f.readLines().next()
  const shebangRegex = /^#!\/usr\/bin\/env -S pkgx /
  if (!shebang.match(shebangRegex)) {
    return false
  }

  const content = await f.readYAML() as ShimContent
  if (!content.siblings) {
    return false
  }

  return true
}

async function isShebang(path: Path): Promise<boolean> {
  const fd = await Deno.open(path.string)
  const buf = new Uint8Array(2)

  if (await fd.read(buf) !== 2) {
    fd.close()
    return false // empty file
  }

  if (buf[0] != 35 || buf[1] != 33) {
    fd.close()
    return false // not an executable script
  }

  fd.close()
  return true
}
